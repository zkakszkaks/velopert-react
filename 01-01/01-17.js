/** useEffect Hook 함수에 대해 알아보자
 *
 *
 * - 컴포넌트가 처음 화면에 나타날때 화면에 사라지게 될때 어떤 특정 작업을 할 수 가 있음
 * - 컴포넌트의 프롭스나 상태가 바뀌어서 업데이트 될 때에도 어떤 작업을 할 있음
 * - 업데이트 되기 전에도 어떤 작업을 할 수 가 있음
 * - 추가적으로 리렌더링 될 때마다 어떤 작업을 등록 할 수 있다.
 *
 * [01] 마운트
 * - 나타난다 라는 것을 의미 한다.
 * - 컴포넌트가 나타나는 것
 *
 * [02] 언마운트
 * - 컴포넌트가 사라지는 것
 */

// 첫번째 시작
useEffect(() => {
  console.log("컴포넌트가 화면에 나타남.");
  // 이 함수가 실행되는 시점은 UI가 화면에 나타난 이후이다.
  // 그래서 여기에서 돔에 바로 접근을 해도 된다.

  // 마운트될때 할 수 있는 작업
  // 1. props로 받은 값을 컴포넌트의 state로 설정할 때
  // 2. 외부 API 요청 REST API 요청
  // 3. 라이브러리 사용 D3, Video.js(라이브러리 인스턴스 생성)
  // 4. setInerval, setTimeout과 같은 작업
  return () => {
    console.log("컴포넌트가 화면에서 사라짐");

    // 언마운트 될 때 할 수 있는 작업
    // 1. setInterval, setTiemout을 사용해서 했던 작업을 제거할 때
    //    clearInterval, clearTimeout과 같은 작업을 여기서 함.
    // 2. 라이브러리 인스턴스 제거 하는 작업
    // 클리너함수를 일종의 뒷정리 함수라고 이해하면 됨.
  };
}, []); // 첫번째 파라메터: 실행하고 싶은 함수
// 두번째 파라메터에는 비어있는 배열을 넣어준다. 이 배열을 뎁스 라고 부른다. deps 디펜던시를 요약한 단어이다.
// 의존 되는 값들을 이 배열 안에 넣어 주면 된다.
// 의존되는 값들이 비어있다면 컴포넌트가 처음에 화면에 나타날 때에만 실행이 된다.

// 두번째 시작
useEffect(() => {
  // user라는 값이 업데이트된 직후에 이 안의 함수가 실행 이된다.
  console.log("user값이 설정 됨", user);
  return () => {
    console.log("user값이 바뀌기 전", user);
  };
}, [user]); // 이 값이 설정되거나 바뀔 때마다 호출이 된다. 마운트 될때에도 값이 나타난다.
// useEffct에 사용할 값은 뎁스 배열에 넣어주어야만 마운트 언마운트 함수 내에서 사용할때 최신의 값을 가리키게 된다.
// 그러므로 useEffect에서 내부에서 사용할 값은 항상 deps에 넣어주어야 한다.
// [] 뎁스가 비어있으면 컴포넌트가 처음 나타날때와 사라질땜나 호출이 된다.
// useEffect 내부에서 함수를 사용할때에도 배열에 넣어주어야만 제대로 작동 한다.

// deps 배열을 생략 하는 경우에는 어떻게 작동하는가
// 컴포넌트가 리렌더링 되고나서 마운트 함수가 호출 된다.
// user의 데이터가 변경 되었을때 모든 컴포넌트가 출력된다.(모든컴포넌트의 마운트 함수가 호출된다.) 수정/등록
// 이렇게 되는 이유는 리액트 컴포넌트에서는 부모 컴포넌트가 리렌더링 되면 자식 컴포넌트도 리렌더링 된다.
// user컴포넌트의 부모 컴포넌트드 userlist 다. userlist에서 users배열이 바뀌에 된다면은 UserList컴포넌트가 리렌더링되고
// 모든 User 컴포넌트도 리렌더링된다. 가상돔상에서는 모든 내용을 렌더링한후 바뀐 부분만 적용 하고 있다.
// 내용이 바뀌지 않았는데 virtual dom에 렌더링 한다고 해서 느려 지지 않는다.
// 항목들이 엄청 많다면 느려질 가능성이 조금 있다.(데이터가 바뀌지 않은 것까지 렌더링 하면.)
// 컴포넌트 리렌더링 성능 최적화 => 데이터가 변경되지 않는 부분은 가삼돔에서 조차 다시 그리지 않는다.

// useEffect 첫번째 파라메터에는 함수, 두번째 파라메터에는 deps라는 배열을 등록 한다.
useEffect(() => {
  // 컴포넌트가 처음 나타날때 호출이 된다.
  console.log(user);
  return () => {
    // 컴포넌트가 사라질 때 호출이 된다.
  };
}, []);

useEffect(() => {
  // 컴포넌트가 처음 나타날때 호출이 된다.
  // user객체가 바뀔때 호출이 된다.
  console.log(user);
  return () => {
    // user 객체가 바뀌기 직전에 호출이 된다.
    // 컴포넌트가 사라지기 전에 호출이 된다.
  };
}, [users]);

// useEffect의 실제 사용 예시
// 1. 벨로그에서 url /react-testing 이라는 이름을 가지로 post를 읽는다.
// 2. 컴포넌트 입장에서는 데이터의 모든 값들을 props로 받아오게 된다.
// 3. 새로고침 했을때는 react-testing 값을 useEffect에서 확인을 해서
//    컴포넌트가 마운트될때 포스트에 대한 정보를 읽어옴
// 4. 다른 링크를 클릭해서 props가 바뀌게 되면서
// props가 바뀌었다면 useEffect를 통해서 새로운 포스트를 불러 오게 하는 것이다.
// 그래서 추상적으로 보자면은
// urlSlug : url뒷부분

useEffect(() => {
  // 컴포넌트가 처음 나타날때 post를 읽어서 불러와준다.
  // urlSlug가 바뀌어도 포스트를 불러와 준다.
  loadPost(username, urlSlug);
}, [username, urlSlug]);
